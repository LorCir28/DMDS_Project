Group Number: 1

Group Members:
* Felli Stefano (1896877)
* Cirillo Lorenzo (1895955)


-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------


CREATE TABLE AND ALTER TABLE


-- TABLE DEFINITIONS
CREATE TABLE continents (
    id integer NOT NULL,
    name character varying(100) NOT NULL
);

CREATE TABLE subcontinents (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    continent_id integer NOT NULL
);

CREATE TABLE countries (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    iso3 character(3),
    phonecode character varying(255),
    capital character varying(255),
    currency_name character varying(255),
    continent_id integer,
    subcontinent_id integer,
    nationality character varying(255),
    latitude numeric(10,8),
    longitude numeric(11,8)
);

CREATE TABLE states (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    country_id integer NOT NULL,
    type character varying(191),
    latitude numeric(10,8),
    longitude numeric(11,8)
);

CREATE TABLE cities (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    state_id integer NOT NULL,
    country_id integer NOT NULL,
    latitude numeric(10,8) NOT NULL,
    longitude numeric(11,8) NOT NULL
);

	
	
	
-- Primary keys
ALTER TABLE cities
	ADD CONSTRAINT cities_pk PRIMARY KEY(id);
	
ALTER TABLE countries
	ADD CONSTRAINT countries_pk PRIMARY KEY(id);
	
ALTER TABLE continents
	ADD CONSTRAINT continents_pk PRIMARY KEY(id);
	
ALTER TABLE states
	ADD CONSTRAINT states_pk PRIMARY KEY(id);
	
ALTER TABLE subcontinents
	ADD CONSTRAINT subcontinents_pk PRIMARY KEY(id);



-- Foreign keys	
ALTER TABLE cities
	ADD CONSTRAINT cities_fk_1 FOREIGN KEY(state_id) REFERENCES states(id),
	ADD CONSTRAINT cities_fk_2 FOREIGN KEY(country_id) REFERENCES countries(id);
	
ALTER TABLE countries
	ADD CONSTRAINT countries_fk_1 FOREIGN KEY(continent_id) REFERENCES continents(id),
	ADD CONSTRAINT countries_fk_2 FOREIGN KEY(subcontinent_id) REFERENCES subcontinents(id);
	
ALTER TABLE states
	ADD CONSTRAINT states_fk FOREIGN KEY(country_id) REFERENCES countries(id);
	
ALTER TABLE subcontinents
	ADD CONSTRAINT subcontinents_fk FOREIGN KEY(continent_id) REFERENCES continents(id);



-- Table updates (only for countries table)
-- Some values of capital attribute of countries table are empty strings. 
-- For uniformity reasons, we set those capitals to NULL.
UPDATE countries
SET capital = NULL
WHERE capital = '';


-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------


QUERIES



-- QUERY 1: STATEMENTS: HAVING

/* DESCRIPTION
for each small country (i.e. a country with less than 20 states), find the name, ISO, currency 
and the number of states
*/
/* EXPLANATION
we make an equi-join between countries and states on the id and select the tuples having less
than 20 states ordering them by descending number of states
*/

select c.name as country_name, c.iso3 as iso3, c.currency_name as currency, count(s.name) as states
from countries c
join states s on c.id = s.country_id
group by c.name, c.iso3, c.currency_name
having count(s.name)<=20
order by count(s.name) desc

----------------------------------------------------------------------------------------------

-- QUERY 2: STATEMENTS: negated nested query, group by

/* DESCRIPTION
for each continent, find number of countries that don't belong to it
*/
/* EXPLANATION
we select only the countries whose name is not in the table returned by the nested query which
returns the name of the countries that belong to the external continent
*/

select r.name as continent_name, count(*) as out_countries
from continents r, countries c
where c.name not in (
	select co.name
 	from countries co 
	join continents re on re.id = co.continent_id
 	where re.name = r.name
) 
and c.continent_id is not null
group by r.name

----------------------------------------------------------------------------------------------

-- QUERY 3 (to be optimized)

/* DESCRIPTION
select the name and the latitude of the northernmost city in the database
*/
/* EXPLANATION
we select the city with the latitude greater or equal than the ones returned by the nested query
that returns the latitudes of all the cities in the database
*/

select name, latitude
from cities
where latitude >= all(
	select latitude
 	from cities
)


-- OPTIMIZED VERSION (no nested query and consequently no comparison with long table)
-- + 99.4% in terms of execution time

select name, latitude
from cities
order by latitude desc
limit 1

----------------------------------------------------------------------------------------------

-- QUERY 4 (to be optimized)

/* DESCRIPTION
return the name and the currency of the southern cities of each continent (with the name) that 
belong to states thar are not autonomous
*/
-- EXPLANATION

-- SUBQUERY: this returns the name and currency of the southern cities of each continent
select distinct c.name as city_name, co.currency_name as currency, sr.name
from cities c 
join countries co on c.country_id = co.id 
join subcontinents sr on co.subcontinent_id = sr.id
where sr.name like 'South%'

intersect

-- SUBQUERY: this returns the name and currency of the cities that are not autonomous
select distinct c.name as city_name, co.currency_name as currency, sr.name
from cities c 
join states s on c.state_id = s.id 
join countries co on co.id = c.country_id
join subcontinents sr on co.subcontinent_id = sr.id
where s.type not like 'autonomous%'


-- OPTIMIZED (not intersection)
-- + 84.6% in terms of execution time

select distinct c.name as city_name, co.currency_name as currency, sr.name
from cities c 
join countries co on c.country_id = co.id 
join subcontinents sr on co.subcontinent_id = sr.id 
join states s on c.state_id = s.id
where s.type not like 'autonomous%' 
and sr.name like 'South%'

----------------------------------------------------------------------------------------------

-- QUERY 5: STATEMENTS: VIEW

/* DESCRITPTION
Show the name and the longitude of all the cities that lays around the Greenwich meridian within
a range of Â±1 (ie such that have a longitude similar to the London one), ordering them by their proximity.
NB. London's longitude is not exactly 0, but -0.12574000
*/

-- this view returns a single-tuple table with the longitude of London
create view london_longitude(longitude) as
	select c.longitude 
    from cities c
    join states s on s.id = c.state_id
    join countries co on co.id = s.country_id 
    where c.name = 'London' 
	and co.name = 'United Kingdom';

/* EXPLANATION
we make a join between cities and the view by selecting only the cities with distance (i.e. the
error from the Greenwich meridian) between -1 and +1
*/

select name, c.longitude, abs(c.longitude - london_longitude.longitude) as distance
from cities c, london_longitude
where abs(c.longitude - london_longitude.longitude) <= 1
order by distance

----------------------------------------------------------------------------------------------

-- QUERY 6: STATEMENTS: outer join, negated nested query

/* DESCRIPTION
for every city that is not a capital, show the phonecode of the corresponding country,
the name of the corresponding continent (if present) and, if present, the subcontinent.
*/
/* EXPLANATION
we need two left joins to get NULL values whenever the continent and/or subcontinent are not
present. We select the cities whose name is not in the table returned by the nested query which 
outputs the cities that are capitals
*/

select c.name as city_name, co.phonecode as city_phonecode, r.name as continent_name, s.name as subcontinent_name
from cities c 
join countries co on co.id = c.country_id
left join continents r on r.id = co.continent_id
left join subcontinents s on s.id = co.subcontinent_id
where c.name not in (
	select distinct capital
	from countries
	where capital is not null
)

----------------------------------------------------------------------------------------------	
	 
-- QUERY 7: STATEMENTS: EXCEPT

/* DESCRIPTION
for each european country that has at least one province, return the name of the country and the 
number of corresponding provinces
*/
-- EXPLANATION

-- subquery: for each country that has at least one province, return the name of 
-- the country and the number of corresponding provinces
select co.name as country_name, count(*) as number_provinces
from countries co 
join states s on co.id = s.country_id
where s.type = 'province'
group by co.name

except

-- subquery: return for each non-european country that has at least one province, return the name
-- of the country and the number of corresponding provinces
select co.name as country_name, count(*) as number_provinces
from countries co 
join states s on co.id = s.country_id 
join continents r on co.continent_id = r.id
where s.type = 'province' 
and r.name != 'Europe'
group by co.name

----------------------------------------------------------------------------------------------

-- QUERY 8 (to be optimized)

/* DESCRIPTION
return the cities that have the same name but different countries, with the subcontinent
*/
/* EXPLANATION
we join cities with itself by keeping cities with only the same name but different id
*/

select distinct c1.name as city1, co1.name as country1, co2.name as country2,
	sb1.name as subcont1, sb2.name as subcont2
from cities c1 
join cities c2 on c1.name = c2.name 
join countries co1 on c1.country_id = co1.id 
join countries co2 on c2.country_id = co2.id 
join subcontinents sb1 on sb1.id = co1.subcontinent_id 
join subcontinents sb2 on sb2.id = co2.subcontinent_id
where c1.id <> c2.id and co1.id <> co2.id
order by c1.name


-- OPTIMIZED (nested query in where clause speeds up. More in detail, we are not comparing the
-- id of each city in the first cities table with the id of each city in the second cities table)
-- + 75.0% in terms of execution time

select distinct c1.name as city1, co1.name as country1, co2.name as country2,
	sb1.name as subcont1, sb2.name as subcont2
from cities c1 join cities c2 on c1.name = c2.name 
join countries co1 on c1.country_id = co1.id
join countries co2 on c2.country_id = co2.id
join subcontinents sb1 on sb1.id = co1.subcontinent_id
join subcontinents sb2 on sb2.id = co2.subcontinent_id
where c1.name in (
	select name
	from cities 
	group by name
	having count(*) > 1
)
and	co1.name <> co2.name
order by c1.name 

----------------------------------------------------------------------------------------------

-- QUERY 9 (to be optimized)

/* DESCRIPTION
for each continent, show the name and the number of cities that are not capital
which have the latitude greater than the latitude of all the italian cities
*/
/* EXPLANATION
we make a join between continents and the table returned by the nested query (called Nested). 
The latter returns the name, latitude and continent_id of the non-capital cities that have the 
latitude of all the italian cities (to achieve that, there are two additional nested queries 
into Nested)
*/

select con.name as continent_name, count(nested.name) as number_cities
from continents con 
join (
	select c.name, c.latitude, co.continent_id
	from cities c join countries co on c.country_id = co.id
	where c.name not in (
		select capital
		from countries
		where capital is not null
	)
	and c.latitude > all (
		select (cit.latitude)
		from cities cit join countries cou on cit.country_id = cou.id
		where cou.name = 'Italy')
) Nested on Nested.continent_id = con.id
group by con.name


-- OPTIMIZED (no nested query in the from clause)
-- + 99.6% in terms of execution time

select con.name as continent_name, count(c.name) as number_cities
from cities c 
join countries co on c.country_id = co.id 
join continents con on co.continent_id = con.id
where c.name not in (
	select capital
	from countries
	where capital is not null
) 
and c.latitude > (
	select max(cit.latitude)
	from cities cit 
	join countries cou on cit.country_id = cou.id
	where cou.name = 'Italy'
)
group by con.name

----------------------------------------------------------------------------------------------

-- QUERY 10 (to be optimized)

/* DESCRIPTION
for each italian region, show the name and the number of provinces that have the latitude greater
than all the spanish cities
*/
/* EXPLANATION
there are two nested queries in the where clause allowing us to get all the italian provinces
(the first one) and the latitudes of all the spanish cities (the second one).
some italian regions are save in the database as 'autonomous region' and some italian provinces
as 'decentralized regional entity'
*/

select s.name as region_name, count(*) as number_provinces
from states s 
join countries co on s.country_id = co.id 
join cities c on c.state_id = s.id
where co.name = 'Italy' 
and (s.type = 'region' or s.type = 'autonomous region') 
and c.name in (
	select st.name
	from countries cou 
	join states st on st.country_id = cou.id
	where cou.name = 'Italy' 
	and (st.type = 'province' or st.type = 'decentralized regional entity')
)												
and c.latitude > all (
	select cit.latitude
	from countries coun 
	join cities cit on cit.country_id = coun.id
	where coun.name = 'Spain'
)
group by s.name


-- OPTIMIZED (Same query but using the following indexes. We create the indexes on the most
-- involved columns in the where clause)
-- + 97.2% in terms of execution time (considering also the time to create the indexes)

-- TO CREATE THE INDEXES
create index idx_states_country_id ON states(country_id);
create index idx_cities_state_id ON cities(state_id);
create index idx_cities_name ON cities(name);
create index idx_states_type ON states(type);
create index idx_countries_name ON countries(name);
create index idx_cities_latitude ON cities(latitude);

select s.name as region_name, count(*) as number_provinces
from states s 
join countries co on s.country_id = co.id 
join cities c on c.state_id = s.id
where co.name = 'Italy' 
and (s.type = 'region' or s.type = 'autonomous region') 
and c.name in (
	select st.name
	from countries cou 
	join states st on st.country_id = cou.id
	where cou.name = 'Italy' 
	and (st.type = 'province' or st.type = 'decentralized regional entity')
)												
and c.latitude > all (
	select cit.latitude
	from countries coun 
	join cities cit on cit.country_id = coun.id
	where coun.name = 'Spain'
)
group by s.name

-- TO DELETE THE INDEXES
drop index idx_states_country_id;
drop index idx_cities_state_id;
drop index idx_cities_name;
drop index idx_states_type;
drop index idx_countries_name;
drop index idx_cities_latitude;


	