CYPHER COMMANDS

everything between round parenthesis is a node 
everything between square parenthesis is a relation


 

# CREATE A NODE
CREATE (:Actor) # create a node with label Actor

CREATE (:Person:Actor) # create a node with label Person and Actor

CREATE (Node1:Actor) # Node1 is the local variable name assigned to the node for Cypher

CREATE (:Actor {name:'Tom Hanks'}) # create a node with label Actor and property name

CREATE (Node1:Actor {name:'Tom Hanks'}) # Node1 is the local variable name assigned to the node for Cypher



# CREATE A RELATIONSHIP
MATCH (Node1:Actor {name:'Tom Hanks'}), (Node2:Actor {name:'Tom Cruise'})
CREATE (Node1)-[:FRIEND_OF {since:1984}]->(Node2);

# less efficient
MATCH (Node1:Actor), (Node2:Actor)
WHERE node1.name = 'Tom Hanks' AND node2.name = 'Tom Cruise'
CREATE (Node1)-[:FRIEND_OF]->(Node2);



# SET
# to set a property of a node
MATCH (Node1:Actor {name:'Tom Hanks'})
SET Node1.age = 70

# to set a property of an edge
MATCH (Node1:Actor {name:'Tom Hanks'})-[r:FRIEND_OF]->(Node2:Actor {name:'Tom Cruise'})
SET r.since = 1984

# to set the label of a node
MATCH (Node1:Actor {name:'Tom Hanks'})
SET node1:Person

# to set the label of an edge
MATCH (Node1:Actor {name:'Tom Hanks'})-[r:FRIEND_OF]->(Node2:Actor {name:'Tom Cruise'})
SET r:COLLEAGUE



# DELETE NODES AND EDGES
MATCH (Node1:Actor {name:'Tom Hanks'})
DETACH DELETE Node1 # this deletes the node and all its links

MATCH ()-[r:FRIEND_OF]-() 
DELETE r # this deletes all the relationships labelled FRIEND_OF



# DELETE PROPERTIES
MATCH (Node1:Actor {name:'Tom Hanks'})
REMOVE Node1.name # this deletes the property name of the node



# TO VISUALIZE THE GRAPH
call db.schema.visualization( )

MATCH (nodes) RETURN nodes;

MATCH (n)-[r]-(m)
RETURN n, r, m



# RETURN QUERIES
MATCH (Node1:Actor {name:'Tom Hanks'})-[:FRIEND_OF]->(Node2:Actor {name:'Tom Cruise'})
RETURN Node1.age

# this considers all the relationships between Node1 and Node2
MATCH (Node1:Actor {name:'Tom Hanks'})-[]->(Node2:Actor {name:'Tom Cruise'})
RETURN Node1.age

# this considers all the nodes involved in the relationship FRIEND_OF
MATCH (Node1)-[r:FRIEND_OF]->(Node2)
RETURN Node1.age



# COLLECT CLAUSE (it collects into a list some values)
CREATE (:Actor {born: 1957})
CREATE (:Actor {born: 1960})
CREATE (:Actor {born: 1966})

MATCH (n:Actor)
COLLECT n.born AS bornList
RETURN bornList # this is [1957, 1960, 1966]



# GROUP BY CLAUSE (it doesn't exist in cypher, it is automatically performed by cypher whenever an aggregated function (COUNT, MIN, MAX, SUM, AVG) is used)
MATCH (n)-[:DIRECTED]->()<-[:ACTED_IN]-(p)
RETURN n.name, COUNT(distinct p) # the 'group by' is automatically performed on everything is before (in this case n.name) the aggregated function (in this case COUNT(distinct p))


# LIMIT CLAUSE (it limits the number of the results to a specified number)
# ORDER BY (it orders the results by a specified order)
MATCH (n)-[:ACTED_IN]-()
RETURN n.name, COUNT(*) AS numberOfMovies
ORDER BY numberOfMovies
LIMIT 5



# WITH CLAUSE (it allows to have conditions on the aggregated functions (like the 'having' clause in sql)). NB the conditions on the aggregated functions must be in the WHERE clause, but to do that we need to use the WITH before
MATCH (n)-[:ACTED_IN]-()
WITH n, COUNT(*) AS numberOfMovies # this is the 'fake group by' as seen before
WHERE  numberOfMovies < 10
RETURN n.name, numberOfMovies



# PATH REGULAR EXPRESSIONS
MATCH (n)-[]->(p) # this matches all the paths of length one (namely with only one link) with every label between n and p
MATCH (n)-[*]->(p) # this matches all the paths of any length with every label between n and p
MATCH (n)-[:FRIEND_OF*]->(p) # this matches all the paths of any length with label FRIEND_OF between n and p
MATCH (n)-[:FRIEND_OF*1..5]->(p) # this matches all the paths of length from 1 to 5 with label FRIEND_OF between n and p
MATCH (n)-[:FRIEND_OF*3]->(p) # this matches all the paths of exactly length 3 with label FRIEND_OF between n and p



# FOREACH CLAUSE (it allows a cycle)
MATCH p=(begin)-[*]->(end)
WHERE begin.name='a' AND end.name='b'
FOREACH (n in NODES(p)) | SET n.marked=TRUE) # this set marked=TRUE for each node in the path p (NODES(p) return all the nodes in the path p)




# NOT EXISTS (it is used in the WHERE clause to specify the non-existence of a path)
return all the people who never acted in a movie directed by Ron Howard
MATCH (n:Person)
WHERE NOT EXISTS ((n)-[:ACTED_IN]->(:Movie)<-[:DIRECTED]-(:Person {name: 'Ron Howard}))



# INDEXES (we can create indexes on properties)
CREATE INDEX myindex FOR (n:Person) ON (n.name) # this creates the index called myindex for the node n on the name property
SHOW INDEXES # this shows all the created indexes
DROP INDEX myindex # this deletes the index with name myindex



# CONSTRAINTS (similar to indexes)
CREATE CONSTRAINT myUniqConstr FOR (p:Person) REQUIRE p.name IS UNIQUE
CREATE CONSTRAINT myUniqConstr FOR (p:Person) REQUIRE p.name IS NOT NULL
CREATE CONSTRAINT myUniqConstr FOR (p:Person) REQUIRE p.name IS NODE KEY